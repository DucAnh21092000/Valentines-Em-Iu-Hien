<!DOCTYPE html>
<html lang="vi">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ch√∫c em y√™u c√≥ Valentine vui v·∫ª üíñ</title>
    <meta name="description"
        content="M·ªôt m√≥n qu√† Valentine ƒë·∫∑c bi·ªát d√†nh ri√™ng cho ng∆∞·ªùi anh y√™u üíñ Nh·ªØng k·ª∑ ni·ªám, nh·ªØng l·ªùi ch√∫c v√† nh·ªØng c·∫£m x√∫c ch√¢n th√†nh nh·∫•t.">

    <meta name="keywords" content="Valentine, Love, K·ª∑ ni·ªám, T√¨nh y√™u, Web t·∫∑ng ng∆∞·ªùi y√™u">

    <meta name="author" content="ƒê·ª©c Anh">

    <!-- Open Graph (chia s·∫ª Facebook/Zalo ƒë·∫πp h∆°n) -->
    <meta property="og:title" content="Valentine üíñ">
    <meta property="og:description" content="M·ªôt m√≥n qu√† nh·ªè nh∆∞ng ch·ª©a ƒë·∫ßy y√™u th∆∞∆°ng d√†nh cho em üíï">
    <meta property="og:type" content="website">
    <meta property="og:image" content="img1.jpg">

    <!-- Icon nh·ªè tr√™n tab -->
    <link rel="icon" href="hien.jpg">

    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: radial-gradient(circle at center, #ff9a9e, #fad0c4);
        }

        canvas {
            display: block;
        }

        /* ================= MEMORY ================= */

        .memory {
            position: absolute;
            inset: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 20;
        }

        .memory.hidden {
            display: none;
        }

        .memory-card {
            width: min(90vw, 420px);
            border-radius: 28px;
            overflow: hidden;
            cursor: pointer;
            transition: 0.4s ease;

            /* c√πng tone n·ªÅn */
            background: linear-gradient(145deg, #ffd6e7, #ffb6c9);

            box-shadow:
                0 30px 70px rgba(255, 64, 129, 0.35),
                inset 0 0 25px rgba(255, 255, 255, 0.4);
        }

        .memory-card {
            backdrop-filter: blur(8px);
        }


        .memory-card img {
            width: 100%;
            height: 250px;
            object-fit: cover;
            border-bottom: 2px solid rgba(255, 255, 255, 0.4);
        }


        .memory-content {
            padding: 20px;
            text-align: center;
        }
    </style>
</head>

<body>

    <canvas id="canvas"></canvas>
    <div id="memoryContainer" class="memory hidden">
        <div class="memory-card" id="memoryCard">
            <img id="memoryImage" src="bantim.jpg">
            <div class="memory-content">
                <h2 id="memoryTitle">H√¥m quay tic toc ·ªü qu√°n cf</h2>
                <p id="memoryText">Ch√∫ng t√¥i b·∫Øn tim v·ªõi nhau n√® üíï</p>
            </div>
        </div>
    </div>

    <script>

        const canvas = document.getElementById("canvas");
        const ctx = canvas.getContext("2d");

        function resize() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }
        resize();
        window.addEventListener("resize", init);

        // ================= CONFIG =================
        const MESSAGES = [
            `Ch√∫c em c√≥ m·ªôt ng√†y Valentine
ng·∫≠p tr√†n y√™u th∆∞∆°ng üíñ`,

            `Hi v·ªçng m·ªëi quan h·ªá ch√∫ng ta ng√†y c√†ng t·ªët h∆°n üíï`,
            `ƒê·ª´ng ƒë·ªÉ ai c√¥ ƒë∆°n trong ch√≠nh t√¨nh y√™u c·ªßa h·ªç`,
            `H√£y ƒë·∫∑t  m√¨nh v√†o v·ªã tr√≠ c·ªßa ƒë·ªëi ph∆∞∆°ng`,
            `Ch√∫ng ta s·∫Ω hi·ªÉu ƒë∆∞·ª£c c·∫£m gi√°c c·ªßa h·ªç`,
            `Quan t√¢m nhau nhi·ªÅu h∆°n nh√≥`
        ];

        const GAP = 5;
        // GAP ƒë·ªông theo font

        let currentMessage = 0;
        let phase = "merge";
        let phaseStart = null;

        const HEART_SIZE = 3.2;
        const MERGE_DURATION = 8000;
        const HOLD_DURATION = 4000;
        const BREAK_DURATION = 3000;
        // const TOTAL_TIME = FLOAT_TIME + MERGE_TIME;
        // ==========================================

        let particles = [];
        let startTime = null;

        function createParticles() {

            particles = [];

            const offCanvas = document.createElement("canvas");
            const offCtx = offCanvas.getContext("2d");

            offCanvas.width = canvas.width;
            offCanvas.height = canvas.height;

            offCtx.fillStyle = "white";
            offCtx.textAlign = "center";
            offCtx.textBaseline = "top";

            // ===== 1. AUTO WRAP =====
            function wrapText(ctx, text, maxWidth) {
                const words = text.split(" ");
                let lines = [];
                let line = "";

                for (let i = 0; i < words.length; i++) {
                    let testLine = line + words[i] + " ";
                    let width = ctx.measureText(testLine).width;

                    if (width > maxWidth && i > 0) {
                        lines.push(line.trim());
                        line = words[i] + " ";
                    } else {
                        line = testLine;
                    }
                }

                lines.push(line.trim());
                return lines;
            }

            // ===== 2. T√çNH FONT SIZE T·ª∞ ƒê·ªòNG =====
            let fontSize = Math.min(canvas.width, canvas.height) / 4;
            const maxWidth = canvas.width * 0.85;
            let lines;

            while (fontSize > 24) {

                offCtx.font = `600 ${fontSize}px "Segoe UI", sans-serif`;

                lines = wrapText(offCtx, MESSAGES[currentMessage]
                    .replace(/\n/g, " "), maxWidth);

                const totalHeight = lines.length * fontSize * 1.4;

                const tooWide = lines.some(line =>
                    offCtx.measureText(line).width > maxWidth
                );

                const tooTall = totalHeight > canvas.height * 0.8;

                if (!tooWide && !tooTall) break;

                fontSize -= 2;
            }

            // ===== 3. GAP ƒë·ªông =====
            const dynamicGap = Math.max(3, Math.floor(fontSize / 22));

            // ===== 4. V·∫º TEXT =====
            const lineHeight = fontSize * 1.4;
            const totalHeight = lines.length * lineHeight;
            const startY = canvas.height / 2 - totalHeight / 2;

            offCtx.font = `600 ${fontSize}px "Segoe UI", sans-serif`;

            lines.forEach((line, i) => {
                offCtx.fillText(line, canvas.width / 2, startY + i * lineHeight);
            });

            const imageData = offCtx.getImageData(
                0, 0, canvas.width, canvas.height
            ).data;

            // ===== 5. L·∫§Y ƒêI·ªÇM CH·ªÆ =====
            for (let y = 0; y < canvas.height; y += dynamicGap) {
                for (let x = 0; x < canvas.width; x += dynamicGap) {

                    const index = (y * canvas.width + x) * 4;

                    if (imageData[index + 3] > 150) {
                        particles.push({
                            sx: Math.random() * canvas.width,
                            sy: Math.random() * canvas.height,
                            x: 0,
                            y: 0,
                            tx: x,
                            ty: y,
                            floatX: (Math.random() - 0.5) * 0.6,
                            floatY: (Math.random() - 0.5) * 0.6
                        });
                    }
                }
            }

            particles.forEach(p => {
                p.x = p.sx;
                p.y = p.sy;
            });
        }


        function drawHeart(x, y, size) {
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.bezierCurveTo(x, y - size, x - size, y - size, x - size, y);
            ctx.bezierCurveTo(x - size, y + size, x, y + size, x, y + size * 1.6);
            ctx.bezierCurveTo(x, y + size * 1.6, x + size, y + size, x + size, y);
            ctx.bezierCurveTo(x + size, y - size, x, y - size, x, y);
            ctx.fill();
        }

        function animate(timestamp) {

            if (!phaseStart) phaseStart = timestamp;
            const elapsed = timestamp - phaseStart;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.fillStyle = "#ff2e63";

            particles.forEach(p => {

                if (phase === "merge") {

                    let progress = elapsed / MERGE_DURATION;
                    if (progress > 1) progress = 1;

                    const ease = 1 - Math.pow(1 - progress, 3);

                    p.x = p.sx + (p.tx - p.sx) * ease;
                    p.y = p.sy + (p.ty - p.sy) * ease;

                }

                else if (phase === "hold") {

                    // gi·ªØ nguy√™n v·ªã tr√≠ text
                    p.x = p.tx;
                    p.y = p.ty;

                }

                else if (phase === "break") {

                    p.x += (Math.random() - 0.5) * 6;
                    p.y += (Math.random() - 0.5) * 6;

                }

                drawHeart(p.x, p.y, HEART_SIZE);
            });

            // ===== CHUY·ªÇN PHASE =====

            if (phase === "merge" && elapsed >= MERGE_DURATION) {
                phase = "hold";
                phaseStart = timestamp;
            }

            else if (phase === "hold" && elapsed >= HOLD_DURATION) {

                // N·∫øu l√† message cu·ªëi -> ƒë·ª©ng y√™n sau khi hold 3s
                if (currentMessage === MESSAGES.length - 1) {
                    showMemory();
                    return;
                }


                phase = "break";
                phaseStart = timestamp;
            }

            else if (phase === "break" && elapsed >= BREAK_DURATION) {

                currentMessage++;

                createParticles();
                phase = "merge";
                phaseStart = timestamp;
            }
            requestAnimationFrame(animate);
        }

        function init() {
            startTime = null;
            createParticles();
            requestAnimationFrame(animate);
        }

        init();
        // ================= MEMORY DATA =================

        const memories = [
            {
                img: "bantim.jpg",
                title: "H√¥m quay tic toc ·ªü qu√°n cf",
                text: "Ch√∫ng t√¥i b·∫Øn tim v·ªõi nhau n√® üíï"
            },
            {
                img: "cuoivoinhau.jpg",
                title: "H√¥m ƒë√≥ l√† h√¥m ƒëi ƒÉn v√† ƒë∆∞·ª£c t√¥ m√†u",
                text: "Ch√∫ng t√¥i l·∫°i c∆∞·ªùi v·ªõi nhau n·ªØa n√® üå∏"
            },
            {
                img: "honnhau.jpg",
                title: "H√¥m t·ªï ch·ª©c Valentine s·ªõm cho em iuu",
                text: "Hihi th√≠ch kho·∫£nh kh·∫Øc n√†y qu√° ‚ù§Ô∏è"
            }
        ];

        let memoryIndex = 0;

        const memoryContainer = document.getElementById("memoryContainer");
        const memoryCard = document.getElementById("memoryCard");
        const memoryImage = document.getElementById("memoryImage");
        const memoryTitle = document.getElementById("memoryTitle");
        const memoryText = document.getElementById("memoryText");

        function showMemory() {
            memoryContainer.classList.remove("hidden");
        }

        // Click ƒë·ªÉ chuy·ªÉn n·ªôi dung
        memoryCard.addEventListener("click", () => {

            memoryIndex++;

            if (memoryIndex >= memories.length) {
                memoryIndex = 0;
            }

            memoryCard.style.opacity = 0;

            setTimeout(() => {
                memoryImage.src = memories[memoryIndex].img;
                memoryTitle.textContent = memories[memoryIndex].title;
                memoryText.textContent = memories[memoryIndex].text;
                memoryCard.style.opacity = 1;
            }, 300);
        });

    </script>
</body>

</html>